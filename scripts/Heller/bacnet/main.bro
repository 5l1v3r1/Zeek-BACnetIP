##! Implements base functionality for bacnet analysis.
##! Generates the bacnet.log file.

# Generated by binpac_quickstart



module bacnet;

@load ./consts
@load base/frameworks/notice/weird

export {

	redef enum Log::ID += { LOG };

	type Info: record {
		## Timestamp for when the event happened.
		ts:     time    &log;
		## Unique ID for the connection.
		uid:    string  &log;
		## The connection's 4-tuple of endpoint addresses/ports.
		id:     conn_id &log;
		
		BVLL_pkts		:	count &log &optional &default = 0;
		NPDU_pkts		:	count &log &optional &default = 0;
		APDU_pkts		:	count &log &optional &default = 0;
		DST			:	string &log &optional &default = "";
		SRC			:	string &log &optional &default = "";
		BVLC_Result		:	count &log &optional &default = 0;
		Write_BDT		:	count &log &optional &default = 0;
		Read_BDT		:	count &log &optional &default = 0;
		Read_BDT_ACK		:	count &log &optional &default = 0;
		FWD_NPDU		:	count &log &optional &default = 0;
		RFD			:	count &log &optional &default = 0;
		Read_FDT		:	count &log &optional &default = 0;
		Read_FDT_ACK		:	count &log &optional &default = 0;
		Del_FDT_Entry		:	count &log &optional &default = 0;
		DBN			:	count &log &optional &default = 0;
		Orig_Uni		:	count &log &optional &default = 0;
		Orig_Broad		:	count &log &optional &default = 0;
		Secure_BVLL		:	count &log &optional &default = 0;
		MT_Who_Is_Router	:	count &log &optional &default = 0;
		MT_I_Am_Router		:	count &log &optional &default = 0;
		MT_Could_Be_Router	:	count &log &optional &default = 0;
		MT_Reject_Msg		:	count &log &optional &default = 0;
		MT_Router_Busy		:	count &log &optional &default = 0;
		MT_Router_Avail		:	count &log &optional &default = 0;
		MT_Init_Route_Tbl	:	count &log &optional &default = 0;
		MT_Init_Route_TblACK	:	count &log &optional &default = 0;
		MT_Establish_Conn	:	count &log &optional &default = 0;
		MT_Break_Conn		:	count &log &optional &default = 0;
		MT_Challenge_Req	:	count &log &optional &default = 0;
		MT_Security_Payload	:	count &log &optional &default = 0;
		MT_Security_Resp	:	count &log &optional &default = 0;
		MT_Req_Key_Update	:	count &log &optional &default = 0;
		MT_Update_Key_Set	:	count &log &optional &default = 0;
		MT_Update_Distr_Key	:	count &log &optional &default = 0;
		MT_Req_Master_Key	:	count &log &optional &default = 0;
		MT_Set_Master_Key	:	count &log &optional &default = 0;
		MT_What_Is_Net_Num	:	count &log &optional &default = 0;
		MT_Net_Num_Is		:	count &log &optional &default = 0;
		MT_Reserved		:	count &log &optional &default = 0;
		MT_Vendor_Custom	:	count &log &optional &default = 0;
		Priority_Normal		:	count &log &optional &default = 0;
		Priority_Urgent		:	count &log &optional &default = 0;
		Priority_Critical	:	count &log &optional &default = 0;
		Priority_Life		:	count &log &optional &default = 0;
		APDU_Total_Segments	:	count &log &optional &default = 0;
		APDU_Conf_Req		:	count &log &optional &default = 0;
		APDU_Conf_Req_Segs	:	count &log &optional &default = 0;
		APDU_Unconf_Req		:	count &log &optional &default = 0;
		APDU_SimpleACK		:	count &log &optional &default = 0;
		APDU_ComplexACK		:	count &log &optional &default = 0;
		APDU_ComplexACK_Segs	:	count &log &optional &default = 0;
		APDU_SegmentACK		:	count &log &optional &default = 0;
		APDU_Error		:	count &log &optional &default = 0;
		APDU_Reject		:	count &log &optional &default = 0;
		APDU_Abort		:	count &log &optional &default = 0;
		# ## TODO: Add other fields here that you'd like to log.
	};

	## Event that can be handled to access the bacnet record as it is sent on
	## to the loggin framework.
	global log_bacnet: event(rec: Info);
}


global MessageType: 	function(c: connection, APDU: string);
global APDULogger: 	function(c: connection, APDU: string);
global set_bacnet: 	function(c: connection, eoc: bool);
global BVLCfunction: 	function(c: connection, BVLC: count);
global ADR_Format: 	function(ADR: string, LEN: count, SD: bool): string;
global Net_Adr:		function(c: connection, NET: count, ADR: string, LEN: count, SD: bool);
global NPDU_Priority:	function(c: connection, Control: count);


# If you want to do port-based detection then
# uncommenting the following, specify the port(s), and comment out
# the "@load-sigs ./dpd.sig" line in the "__load__.bro" file:

# const ports = { 47808/udp };

# redef likely_server_ports += { ports };

redef record connection += {

	bacnet: Info &optional;


};


event bro_init() &priority=5
	{

	Log::create_stream(bacnet::LOG, [$columns=Info, $ev=log_bacnet, $path="bacnet"]);


	# TODO: If you're using port-based DPD, uncomment this.
	# Analyzer::register_for_ports(Analyzer::ANALYZER_BACNET, ports);
	}


#Logs BVLC Results packets
event bacnet_ethernet_BVLC_Result(c: connection, BVLC_Header : bacnet::BVLCHeaders, Result : count) &priority=5
	{
	set_bacnet(c, F);

	#Increment BVLC related log fields
	BVLCfunction(c, BVLC_Header$Function);

	}

#Logs BVLC write and read ACK broadcast distribution table messages
event bacnet_ethernet_BVLC_Broadcast_Distribution_Table(c: connection, BVLC_Header : bacnet::BVLCHeaders, BDT : string)
	{
	set_bacnet(c, F);

	#Increment BVLC related log fields
	BVLCfunction(c, BVLC_Header$Function);
	}

#Logs BVLC read broadcast distribution table or read foreign device table messages
event bacnet_ethernet_BVLC_Read_B_F(c: connection, BVLC_Header : bacnet::BVLCHeaders)
	{
	set_bacnet(c, F);

	#Increment BVLC related log fields
	BVLCfunction(c, BVLC_Header$Function);
	}

#Logs BVLC register foreign device messages
event bacnet_ethernet_BVLC_RFD(c: connection, BVLC_Header : bacnet::BVLCHeaders, TTL : count)
	{
	set_bacnet(c, F);

	#Increment BVLC related log fields
	BVLCfunction(c, BVLC_Header$Function);
	}

event bacnet_ethernet_BVLC_Read_Foreign_Device_Table_Ack(c: connection, BVLC_Header : bacnet::BVLCHeaders, FDT : string)
	{
	set_bacnet(c, F);

	#Increment BVLC related log fields
	BVLCfunction(c, BVLC_Header$Function);
	}

event bacnet_ethernet_BVLC_Del_FD(c: connection, BVLC_Header : bacnet::BVLCHeaders, FDE : string)
	{
	set_bacnet(c, F);

	#Increment BVLC related log fields
	BVLCfunction(c, BVLC_Header$Function);
	}

event bacnet_ethernet_BVLC_Secure(c: connection, BVLC_Header : bacnet::BVLCHeaders)
	{
	set_bacnet(c, F);

	#Increment BVLC related log fields
	BVLCfunction(c, BVLC_Header$Function);
	}

event bacnet_ethernet_BVLC_Unknown_Type(c: connection, BVLC_Type : count, BVLC_Function : count)
	{
	set_bacnet(c, F);

	#Increment BVLC related log fields
	BVLCfunction(c, BVLC_Function);
	}


event bacnet_ethernet_NPDU(c: connection, BVLC_Header : bacnet::BVLCHeaders, NPDU : bacnet::NPDUs, NET : count, LEN : count, ADR : string, Hop_Count : count, APDU : string) &priority=5
	{
	set_bacnet(c, F);
	
	#Increment BVLC related log fields
	BVLCfunction(c, BVLC_Header$Function);

	#Log the network priority of the NPDU
	NPDU_Priority(c, NPDU$Control);

	#If the NPDU packet has a Message Type then add to the appropriate message type counter
	if (NPDU$Control & 0x80 == 0x80)
		MessageType(c, APDU);

	#If the NPDU packet has an APDU log then add to the appropriate APDU type counter
	if (NPDU$Control & 0x80 == 0x00)
		APDULogger(c, APDU);

	#If the packet has a non-IP based source or destination then log it
	if (NPDU$Control & 0x28 == 0x20)
		Net_Adr(c, NET, ADR, LEN, F);
	else
		if (NPDU$Control & 0x28 == 0x08)
			Net_Adr(c, NET, ADR, LEN, T);
	}

event bacnet_ethernet_NPDU_SD(c: connection, BVLC_Header : bacnet::BVLCHeaders, NPDU : bacnet::NPDUs, SNET : count, SLEN : count, DNET : count, DLEN : count, SADR : string, DADR : string, Hop_Count : count, APDU : string)
	{
	set_bacnet(c, F);
	
	#Increment BVLC related log fields
	BVLCfunction(c, BVLC_Header$Function);

	#Log the network priority of the NPDU
	NPDU_Priority(c, NPDU$Control);

	#If the NPDU packet has a Message Type then add to the appropriate message type counter
	if (NPDU$Control & 0x80 == 0x80)
		MessageType(c, APDU);

	#If the NPDU packet has an APDU log then add to the appropriate APDU type counter
	if (NPDU$Control & 0x80 == 0x00)
		APDULogger(c, APDU);

	#Log non-IP based source and destination
	Net_Adr(c, DNET, DADR, DLEN, F);
	Net_Adr(c, SNET, SADR, SLEN, T);

	}

event bacnet_ethernet_NPDU_No(c: connection, BVLC_Header : bacnet::BVLCHeaders, NPDU : bacnet::MiniNPDUs, NET : count, LEN : count, ADR : string, Hop_Count : count, APDU : string)
	{
	set_bacnet(c, F);
	
	#Increment BVLC related log fields
	BVLCfunction(c, BVLC_Header$Function);

	#Log the network priority of the NPDU
	NPDU_Priority(c, NPDU$Control);

	#If the NPDU packet has a Message Type then add to the appropriate message type counter
	if (NPDU$Control & 0x80 == 0x80)
		MessageType(c, APDU);

	#If the NPDU packet has an APDU log then add to the appropriate APDU type counter
	if (NPDU$Control & 0x80 == 0x00)
		APDULogger(c, APDU);

	#If the packet has a non-IP based source or destination then log it
	if (NPDU$Control & 0x28 == 0x20)
		Net_Adr(c, NET, ADR, LEN, F);
	else
		if (NPDU$Control & 0x28 == 0x08)
			Net_Adr(c, NET, ADR, LEN, T);

	}


event bacnet_ethernet_NPDU_SD_No(c: connection, BVLC_Header : bacnet::BVLCHeaders, NPDU : bacnet::MiniNPDUs, SNET : count, SLEN : count, DNET : count, DLEN : count, SADR : string, DADR : string, Hop_Count : count, APDU : string)
	{
	set_bacnet(c, F);
	
	#Increment BVLC related log fields
	BVLCfunction(c, BVLC_Header$Function);

	#Log the network priority of the NPDU
	NPDU_Priority(c, NPDU$Control);

	#If the NPDU packet has a Message Type then add to the appropriate message type counter
	if (NPDU$Control & 0x80 == 0x80)
		MessageType(c, APDU);

	#If the NPDU packet has an APDU log then add to the appropriate APDU type counter
	if (NPDU$Control & 0x80 == 0x00)
		APDULogger(c, APDU);

	#Log non-IP based source and destination
	Net_Adr(c, DNET, DADR, DLEN, F);
	Net_Adr(c, SNET, SADR, SLEN, T);
	}




#Increments the appropriate BVLC function type log fields
function BVLCfunction(c: connection, BVLC: count)
{

			c$bacnet$BVLL_pkts = c$bacnet$BVLL_pkts + 1;	
	switch BVLC
		{
			#BVLC Results
			case 0x00:	
				c$bacnet$BVLC_Result = c$bacnet$BVLC_Result + 1;
				break;

			#Write broadcast distribution table
			case 0x01:	
				c$bacnet$Write_BDT = c$bacnet$Write_BDT + 1;
				break;

			#Read broadcast distribution table
			case 0x02:	
				c$bacnet$Read_BDT = c$bacnet$Read_BDT + 1;
				break;

			#Read broadcast distribution table ACK
			case 0x03:	
				c$bacnet$Read_BDT_ACK = c$bacnet$Read_BDT_ACK + 1;
				break;

			#Forwarded NPDU
			case 0x04:	
				c$bacnet$FWD_NPDU = c$bacnet$FWD_NPDU + 1;	
				break;

			#Register Foreign Device
			case 0x05:	
				c$bacnet$RFD = c$bacnet$RFD + 1;
				break;

			#Read Foreign Device Table
			case 0x06:	
				c$bacnet$Read_FDT = c$bacnet$Read_FDT + 1;
				break;

			#Read Foreign Device Table ACK
			case 0x07:	
				c$bacnet$Read_FDT_ACK = c$bacnet$Read_FDT_ACK + 1;
				break;

			#Delete Foreign Device Table Entry
			case 0x08:	
				c$bacnet$Del_FDT_Entry = c$bacnet$Del_FDT_Entry + 1;
				break;

			#Distribute Broadcast to Network
			case 0x09:	
				c$bacnet$DBN = c$bacnet$DBN + 1;	
				break;
			#Original Unicast NPDU
			case 0xA:	
				c$bacnet$Orig_Uni = c$bacnet$Orig_Uni + 1;	
				break;
			#Original Broadcast NPDU
			case 0x0B:	
				c$bacnet$Orig_Broad = c$bacnet$Orig_Broad + 1;	
				break;

			#Secure BVLL message
			case 0x0C:	
				c$bacnet$Secure_BVLL = c$bacnet$Secure_BVLL + 1;
				break;
		}

}


#Increments the appropriate APDU Type log fields
function APDULogger(c: connection, APDU: string)
	{
		local APDU_first	: count = bytestring_to_count(APDU[0:1]);
		local APDU_Type		: count = ( APDU_first / 16 ); #APDU type is determined by the highest 4 bits of the first APDU byte
		local start_byte	: count;

		c$bacnet$NPDU_pkts = c$bacnet$NPDU_pkts + 1;
		c$bacnet$APDU_pkts = c$bacnet$APDU_pkts + 1;

		switch APDU_Type
			{
				#BACnet-Confirmed-Request-PDU
				case 0x0:
					c$bacnet$APDU_Conf_Req = c$bacnet$APDU_Conf_Req + 1;

					if(APDU_first & 0x08 == 0x08)
						{
						c$bacnet$APDU_Conf_Req_Segs = c$bacnet$APDU_Conf_Req_Segs + 1;
						c$bacnet$APDU_Total_Segments = c$bacnet$APDU_Total_Segments + 1;
						}
					break;

				case 0x1:
					c$bacnet$APDU_Unconf_Req = c$bacnet$APDU_Unconf_Req + 1;
					break;

				case 0x2:
					c$bacnet$APDU_SimpleACK = c$bacnet$APDU_SimpleACK + 1;
					break;

				case 0x3:
					c$bacnet$APDU_ComplexACK = c$bacnet$APDU_ComplexACK + 1;
					if(APDU_first & 0x08 == 0x08)
						{
						c$bacnet$APDU_ComplexACK_Segs = c$bacnet$APDU_ComplexACK_Segs + 1;
						c$bacnet$APDU_Total_Segments = c$bacnet$APDU_Total_Segments + 1;
						}
					#info$APDU_Srvc_Choice 	= APDU_C_Service[bytestring_to_count(APDU[start_byte:start_byte + 1])];
					break;

				case 0x4:
					c$bacnet$APDU_SegmentACK = c$bacnet$APDU_SegmentACK + 1;
					break;

				case 0x5:
					c$bacnet$APDU_Error = c$bacnet$APDU_Error + 1;
					break;

				case 0x6:
					c$bacnet$APDU_Reject = c$bacnet$APDU_Reject + 1;
					break;

				case 0x7:
					c$bacnet$APDU_Abort = c$bacnet$APDU_Abort + 1;
					break;

			}

	}


#Increments the appropriate NPDU Message Type log fields
function MessageType(c: connection, APDU: string)
	{
		local message_code 	: count;

		message_code = bytestring_to_count(APDU[0:1]);

		c$bacnet$NPDU_pkts = c$bacnet$NPDU_pkts + 1;

		if (message_code <= 0x13)
		{
		switch message_code
	    		{
				case 0x00:
					c$bacnet$MT_Who_Is_Router = c$bacnet$MT_Who_Is_Router + 1;	
					break;
	
				case 0x01:		
					c$bacnet$MT_I_Am_Router = c$bacnet$MT_I_Am_Router + 1;	
					break;
	
				case 0x02:
					c$bacnet$MT_Could_Be_Router = c$bacnet$MT_Could_Be_Router + 1;	
					break;
	
				case 0x03:
					c$bacnet$MT_Reject_Msg = c$bacnet$MT_Reject_Msg + 1;	
					break;
	
				case 0x04:
					c$bacnet$MT_Router_Busy = c$bacnet$MT_Router_Busy + 1;	
					break;

				case 0x05:
					c$bacnet$MT_Router_Avail = c$bacnet$MT_Router_Avail + 1;	
					break;

				case 0x06:
					c$bacnet$MT_Init_Route_Tbl = c$bacnet$MT_Init_Route_Tbl + 1;	
					break;

				case 0x07:
					c$bacnet$MT_Init_Route_TblACK = c$bacnet$MT_Init_Route_TblACK + 1;	
					break;

				case 0x08:
					c$bacnet$MT_Establish_Conn = c$bacnet$MT_Establish_Conn + 1;	
					break;

				case 0x09:
					c$bacnet$MT_Break_Conn = c$bacnet$MT_Break_Conn + 1;	
					break;

				case 0x0A:
					c$bacnet$MT_Challenge_Req = c$bacnet$MT_Challenge_Req + 1;	
					break;

				case 0x0B:
					c$bacnet$MT_Security_Payload = c$bacnet$MT_Security_Payload + 1;	
					break;

				case 0x0C:
					c$bacnet$MT_Security_Resp = c$bacnet$MT_Security_Resp + 1;	
					break;

				case 0x0D:
					c$bacnet$MT_Req_Key_Update = c$bacnet$MT_Req_Key_Update + 1;	
					break;

				case 0x0E:
					c$bacnet$MT_Update_Key_Set = c$bacnet$MT_Update_Key_Set + 1;	
					break;

				case 0x0F:
					c$bacnet$MT_Update_Distr_Key = c$bacnet$MT_Update_Distr_Key + 1;	
					break;

				case 0x10:
					c$bacnet$MT_Req_Master_Key = c$bacnet$MT_Req_Master_Key + 1;	
					break;

				case 0x11:
					c$bacnet$MT_Set_Master_Key = c$bacnet$MT_Set_Master_Key + 1;	
					break;

				case 0x12:
					c$bacnet$MT_What_Is_Net_Num = c$bacnet$MT_What_Is_Net_Num + 1;	
					break;

				case 0x13:
					c$bacnet$MT_Net_Num_Is = c$bacnet$MT_Net_Num_Is + 1;	
					break;
			}
		}
		else
			if ((message_code > 0x13) && (message_code <= 0x7F))
				c$bacnet$MT_Reserved = c$bacnet$MT_Reserved + 1;
			else
				c$bacnet$MT_Vendor_Custom = c$bacnet$MT_Vendor_Custom + 1;
	}



## Fill out the c$bacnet record for logging
function set_bacnet(c: connection, eoc: bool)
	{
	if ( ! c?$bacnet )
		{
		local tmp: Info;
		c$bacnet = tmp;
		}

	c$bacnet$ts=c$start_time;
	c$bacnet$id = c$id;
	c$bacnet$uid = c$uid;


#	if ( eoc )
#		{
#
#		}
}


event connection_state_remove(c: connection) &priority=5
	{
	set_bacnet(c, T);
	}

event connection_state_remove(c: connection) &priority=-5
	{
	Log::write(bacnet::LOG, c$bacnet);
	}



#Takes in the various NPDU address formats and returns an appropriate string
function ADR_Format(ADR: string, LEN: count, SD: bool): string
	{
		local ADDR : string;
		switch LEN
    		{
		    case 0:
			ADDR = "";
			break;
		    case 1:
		        ADDR = fmt("%d (ARCNET or MS/TP) |",bytestring_to_count(ADR));
			break;

		# ############# TODO: NEED TO TEST LONTALK CASES
		    case 2:
			# If Source Address SD == 1, else SD == 0 and it's a pain in the neck destination address
		        if (SD)
				ADDR = fmt("%d:%d (LonTalk)",bytestring_to_count(ADR[0]), bytestring_to_count(ADR[1]));
			else
			{
				if(bytestring_to_count(ADR[0]) == 0x00)
					ADDR = fmt("%d (LonTalk Dst Subnet) |", bytestring_to_count(ADR[1]));
				else
					if(bytestring_to_count(ADR[0]) == 0x00)
						ADDR = fmt("%d (LonTalk Dst Group) |", bytestring_to_count(ADR[1]));
			}
			break;

		# ############# TODO: IPv6 not supported in this analyzer (yet?)
		    case 3:
		        ADDR = fmt("%d (IPv6 - not supported) |", bytestring_to_count(ADR));
			break;

		    case 6:
			local BIPa 	: addr;
			local BIPp 	: count;

			BIPa  = raw_bytes_to_v4_addr(ADR);	
			BIPp  = bytestring_to_count(ADR[4:6]);
		
			ADDR = fmt("%s",BIPa) + ":" + fmt("%d (IPv4 BACnet/IP) |",BIPp);
		        break;

		# ############# TODO: NEED TO TEST LONTALK CASES
		    case 7:
		        ADDR = fmt("Dst Subnet: %d Neuron ID: %d (LonTalk ) |", bytestring_to_count(ADR[0]), bytestring_to_count(ADR[1:7]));
			break;

		    default:
		        ADDR = fmt("%d (unknown protocol)", bytestring_to_count(ADR));
			break;
    		}

		return ADDR;
	}

#Takes in the various NPDU address formats and returns an appropriate string
function Net_Adr(c: connection, NET: count, ADR: string, LEN: count, SD: bool)
{
	local msg : string = "";
	local tmp : string = "";

	if (!SD)
	{
		tmp = c$bacnet$DST;

		if ( |c$bacnet$DST| < 1 )
			msg = fmt("DNET: %d ", NET);
			else
				msg = fmt(" DNET: %d ", NET);
				
			if ( (LEN == 0) && (|ADR| == 1))
				msg = msg + "DADR: Broadcast |";
			else
				msg = msg + fmt("DADR: %s", ADR_Format(ADR, LEN, F));
	
			if (strstr(tmp, strip(msg)) == 0)
			c$bacnet$DST = c$bacnet$DST + msg;
	}
	else
	{
		tmp = c$bacnet$SRC;

		if ( |c$bacnet$SRC| < 1 )
			msg = fmt("SNET: %d ", NET);
			else
				msg = fmt(" SNET: %d ", NET);
		
		if ( LEN > 0)
			msg = msg + fmt("SADR: %s", ADR_Format(ADR, LEN, T));
		if (strstr(tmp, strip(msg)) == 0)
			c$bacnet$SRC = c$bacnet$SRC + msg;			
	}
}

#Logs the network priority of an NPDU packet
function NPDU_Priority(c: connection, Control: count)
{
	switch (Control & 0x03)
	{
		case 0x00:	# Normal message priority
			c$bacnet$Priority_Normal = c$bacnet$Priority_Normal + 1;
			break;		

		case 0x01:	# Urgent priority message
			c$bacnet$Priority_Urgent = c$bacnet$Priority_Urgent + 1;
			break;		

		case 0x02:	# Critical equipment priority message
			c$bacnet$Priority_Critical = c$bacnet$Priority_Critical + 1;
			break;		

		case 0x03:	# Life safety message
			c$bacnet$Priority_Life = c$bacnet$Priority_Life + 1;
			break;		
		
	}
}