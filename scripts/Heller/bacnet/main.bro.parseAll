##! Implements base functionality for bacnet analysis.
##! Generates the bacnet.log file.

# Generated by binpac_quickstart



module bacnet;

@load ./consts
@load base/frameworks/notice/weird

export {

	redef enum Log::ID += { LOG };

	type Info: record {
		## Timestamp for when the event happened.
		ts:     time    &log;
		## Unique ID for the connection.
		uid:    string  &log;
		## The connection's 4-tuple of endpoint addresses/ports.
		id:     conn_id &log;
		
		Function		:	string &log;
		BVLC_Result		:	string &log &optional;
		BDT			:	string &log &optional;
		TTL			:	count &log &optional; # # Try to update this type to 'time'
		FDT			:	string &log &optional;
		BIP			:	string &log &optional;
		Control			:	count &log &optional;
		Priority		:	string &log &optional;
		Expect_Reply		:	string &log &optional;
		DNET			:	count &log &optional;
		DADR			:	string &log &optional;
		SNET			:	count &log &optional;
		SADR			:	string &log &optional;
		Message_Type		:	string &log &optional;
		Message_Type_Info	:	string &log &optional;
		Vendor_ID		:	count &log &optional;
		Hop_Count		:	count &log &optional;
		APDU_Type		:	string &log &optional;
		APDU_Data		:	string &log &optional;
		APDU_Max_Segs		:	string &log &optional;
		APDU_Max_Resp		:	string &log &optional;
		APDU_Invoke_ID		:	count &log &optional;
		APDU_Seq_Num		:	count &log &optional;
		APDU_Prop_Win_Size	:	count &log &optional;
		APDU_Act_Win_Size	:	count &log &optional;
		APDU_Srvc_Choice	:	string &log &optional;
		APDU_Srvc_Req		:	string &log &optional;
		Sec_Control		:	count &log &optional;
		Sec_Key_Rev		:	count &log &optional;
		Sec_Key_ID		:	count &log &optional;
		Sec_SDI			:	count &log &optional;
		Sec_Message_ID		:	count &log &optional;
		Sec_Time_Stamp		:	count &log &optional;
		# ## TODO: Add other fields here that you'd like to log.
	};

	## Event that can be handled to access the bacnet record as it is sent on
	## to the loggin framework.
	global log_bacnet: event(rec: Info);
}

global ADR_Format: function(ADR: string, LEN: count, SD: bool): string;
global MessageType: function(APDU: string): string;
global APDULogger: function(info: Info, c: connection, APDU: string);

# If you want to do port-based detection then
# uncommenting the following, specify the port(s), and comment out
# the "@load-sigs ./dpd.sig" line in the "__load__.bro" file:

# const ports = { 47808/udp };

# redef likely_server_ports += { ports };

event bro_init() &priority=5
	{

	Log::create_stream(bacnet::LOG, [$columns=Info, $ev=log_bacnet, $path="bacnet"]);


	# TODO: If you're using port-based DPD, uncomment this.
	# Analyzer::register_for_ports(Analyzer::ANALYZER_BACNET, ports);
	}

#Logs BVLC Results packets
event bacnet_ethernet_BVLC_Result(c: connection, BVLC_Header : bacnet::BVLCHeaders, Result : count) &priority=5
	{
	local info: Info;
	info$ts  = network_time();
	info$uid = c$uid;
	info$id  = c$id;
	info$Function = BVLC_function_codes[BVLC_Header$Function];
	info$BVLC_Result = BVLC_result_codes[Result];

	Log::write(bacnet::LOG, info);
	}

#Logs BVLC Write Broadcast Distribution packets and BVLC Read Broadcast Distribution Ack packets
event bacnet_ethernet_BVLC_Broadcast_Distribution_Table(c: connection, BVLC_Header : bacnet::BVLCHeaders, BDT : string) &priority=5
	{
	local info: Info;
	info$ts  = network_time();
	info$uid = c$uid;
	info$id  = c$id;
	info$Function = BVLC_function_codes[BVLC_Header$Function];

	local p 	: count = 0;
	local temp	: string = "|";
	local BIPa 	: addr;
	local BIPp 	: count;
	local BIPs	: addr;

# # This while loop extracts the BVLC Broadcast-Distribution-Table entries and formats them as {IP}:{port} Mask:{subnet mask}
	while(p < (|BDT|/10))
		{
		BIPa  = raw_bytes_to_v4_addr(BDT[(p*10):]);	
		BIPs  = raw_bytes_to_v4_addr(BDT[6+(p*10):]);
		BIPp  = bytestring_to_count(BDT[4+(p*10):6+(p*10)]);

		temp = temp + fmt("%s",BIPa) + ":" + fmt("%d",BIPp) + " Mask:" + fmt("%s",BIPs) + "|";
		p = p +1;
		}

	info$BDT = temp;

	Log::write(bacnet::LOG, info);

	}

#Logs BVLC Read Broadcast Distribution Table (request) and BVLC Read Foreign Device Table (request)
event bacnet_ethernet_BVLC_Read_B_F(c: connection, BVLC_Header : bacnet::BVLCHeaders) &priority=5
	{
	local info: Info;
	info$ts  = network_time();
	info$uid = c$uid;
	info$id  = c$id;
	info$Function = BVLC_function_codes[BVLC_Header$Function];

	Log::write(bacnet::LOG, info);
	}

#Logs BVLC Register Foreign Device packets
event bacnet_ethernet_BVLC_RFD(c: connection, BVLC_Header : bacnet::BVLCHeaders, TTL : count) &priority=5
	{
	local info: Info;
	info$ts  = network_time();
	info$uid = c$uid;
	info$id  = c$id;
	info$Function = BVLC_function_codes[BVLC_Header$Function];
	info$TTL = TTL;

	Log::write(bacnet::LOG, info);
	}


#Logs BVLC Read Foreign Deivce Table Ack packets
event bacnet_ethernet_BVLC_Broadcast_Distribution_Table(c: connection, BVLC_Header : bacnet::BVLCHeaders, FDT : string) &priority=5
	{
	local info: Info;
	info$ts  = network_time();
	info$uid = c$uid;
	info$id  = c$id;
	info$Function = BVLC_function_codes[BVLC_Header$Function];

	local p 	: count = 0;
	local temp	: string = "|";
	local BIPa 	: addr;
	local BIPp 	: count;
	local TTL	: count;
	local purge	: count;

# # This while loop extracts the BVLC Foreign-Deivce-Table entries and formats them as {IP}:{port} TTL:{TTL} Purge: {purge}
	while(p < (|FDT|/10))
		{
		BIPa  = raw_bytes_to_v4_addr(FDT[(p*10):]);	
		BIPp  = bytestring_to_count(FDT[4+(p*10):6+(p*10)]);
		TTL   = bytestring_to_count(FDT[6+(p*10):8+(p*10)]);
		purge   = bytestring_to_count(FDT[8+(p*10):10+(p*10)]);

		temp = temp + fmt("%s",BIPa) + ":" + fmt("%d",BIPp) + " TTL:" + fmt("%d",TTL) + " Purge:" + fmt("%d",purge) + "|";
		p = p +1;
		}

	info$FDT = temp;

	Log::write(bacnet::LOG, info);

	}


#Logs BVLC Delete Foreign Deivce Entry packets
event bacnet_ethernet_BVLC_Del_FD(c: connection, BVLC_Header : bacnet::BVLCHeaders, FDE : string) &priority=5
	{
	local info: Info;
	info$ts  = network_time();
	info$uid = c$uid;
	info$id  = c$id;
	info$Function = BVLC_function_codes[BVLC_Header$Function];
		
	info$FDT = ADR_Format(FDE, |FDE|, F);

	Log::write(bacnet::LOG, info);

	}

#Logs BVLC Secure packets
event bacnet_ethernet_BVLC_Secure(c: connection, BVLC_Header : bacnet::BVLCHeaders) &priority=5
	{
	local info: Info;
	info$ts  = network_time();
	info$uid = c$uid;
	info$id  = c$id;
	info$Function = BVLC_function_codes[BVLC_Header$Function];

	Log::write(bacnet::LOG, info);

	}

#-----------------------------------------------------------------------------------

#Logs NPDU packets
event bacnet_ethernet_NPDU(c: connection, BVLC_Header : bacnet::BVLCHeaders, NPDU : bacnet::NPDUs, NET : count, LEN : count, ADR : string, Hop_Count : count, APDU : string) &priority=5
	{
	
	##print "Logging NPDU packet!!!  LEN=", LEN;

	local info	:  Info;

	info$ts  	= network_time();
	info$uid 	= c$uid;
	info$id  	= c$id;
	info$Function 	= BVLC_function_codes[BVLC_Header$Function];
	info$Control 	= NPDU$Control;

	if (NPDU$Control & 0x50 > 0)					#Bits 4 & 6 must = 0
	{
		local ctr = Weird::Info($ts=network_time(), $name="BACnet/IP invalid NPDU Control field value", $uid=c$uid, $id=c$id);
		Weird::weird(ctr);
	}
		
	info$Priority	= NPDU_prior_codes[(NPDU$Control & 0x03)];
	info$Expect_Reply = NPDU_reply[(NPDU$Control & 0x04)];

	if (BVLC_Header$Function == 0x04)
		info$BIP 	= fmt("%s",NPDU$IP) + ":" + fmt("%d",NPDU$Port);

	
	if (NPDU$Control & 0x28 == 0x20)
	{
		info$DNET	= NET;
			if ( (LEN == 0) && (|ADR| == 1))
				info$DADR = "Broadcast";
			else
				info$DADR = ADR_Format(ADR, LEN, F);

		info$Hop_Count = Hop_Count;
	}
	else
	{
		if (NPDU$Control & 0x28 == 0x08)
			info$SNET	= NET;
			if ( LEN == 0)
				info$SADR = "Invalid";
			else
				info$SADR = ADR_Format(ADR, LEN, T);;
	}


	#If the NPDU packet has a Message Type, parse the data
	if (NPDU$Control & 0x80 == 0x80)
		info$Message_Type = MessageType(APDU);

	#If the NPDU packet has an APDU, parse the data
	if (NPDU$Control & 0x80 == 0x00)
		APDULogger(info, c, APDU);


	Log::write(bacnet::LOG, info);
	}

#Logs NPDU packets other than forwarded NPDUs
event bacnet_ethernet_NPDU_SD_No(c: connection, BVLC_Header : bacnet::BVLCHeaders, NPDU : bacnet::MiniNPDUs, SNET : count, SLEN : count, DNET : count, DLEN : count, SADR : string, DADR : string, Hop_Count : count, APDU : string)  &priority=5
	{
	
	##print "Logging non FWD NPDU with source packet!!!";

	local info: Info;
	info$ts  	= network_time();
	info$uid 	= c$uid;
	info$id  	= c$id;
	info$Function 	= BVLC_function_codes[BVLC_Header$Function];
	info$Control 	= NPDU$Control;
	info$DNET	= DNET;
	info$Priority	= NPDU_prior_codes[(NPDU$Control & 0x03)];
	info$Expect_Reply = NPDU_reply[(NPDU$Control & 0x04)];

	if (NPDU$Control & 0x50 > 0)					#Bits 4 & 6 must = 0
	{
		local ctr = Weird::Info($ts=network_time(), $name="BACnet/IP invalid NPDU Control field value", $uid=c$uid, $id=c$id);
		Weird::weird(ctr);
	}

	if ( DLEN == 0)
		info$DADR = "Broadcast";
	else
		info$DADR = ADR_Format(DADR, DLEN, F);

	info$SNET	= SNET;

	if ( SLEN == 0)
		info$SADR = "Invalid";
	else
		info$SADR = ADR_Format(SADR, SLEN, T);;	

	#If the NPDU packet has a Message Type, parse the data
	if (NPDU$Control & 0x80 == 0x80)
		info$Message_Type = MessageType(APDU);

	#If the NPDU packet has an APDU, parse the data
	if (NPDU$Control & 0x80 == 0x00)
		APDULogger(info, c, APDU);


	Log::write(bacnet::LOG, info);
	}


event bacnet_ethernet_NPDU_No(c: connection, BVLC_Header : bacnet::BVLCHeaders, NPDU : bacnet::MiniNPDUs, NET : count, LEN : count, ADR : string, Hop_Count : count, APDU : string) &priority=5
	{
	
	##print "Logging non FWD NPDU packet!!!  LEN=", LEN;

	local info: Info;
	info$ts  	= network_time();
	info$uid 	= c$uid;
	info$id  	= c$id;
	info$Function 	= BVLC_function_codes[BVLC_Header$Function];
	info$Control 	= NPDU$Control;
	info$Priority	= NPDU_prior_codes[(NPDU$Control & 0x03)];
	info$Expect_Reply = NPDU_reply[(NPDU$Control & 0x04)];


	if (NPDU$Control & 0x50 > 0)					#Bits 4 & 6 must = 0
	{
		local ctr = Weird::Info($ts=network_time(), $name="BACnet/IP invalid NPDU Control field value", $uid=c$uid, $id=c$id);
		Weird::weird(ctr);
	}
	
	if (NPDU$Control & 0x28 == 0x20)
	{
		info$DNET	= NET;
			if ( (LEN == 0) && (|ADR| == 1))
				info$DADR = "Broadcast";
			else
				info$DADR = ADR_Format(ADR, LEN, F);

		info$Hop_Count = Hop_Count;
	}
	else
	{
		if (NPDU$Control & 0x28 == 0x08)
			info$SNET	= NET;
			if ( LEN == 0)
				info$SADR = "Invalid";
			else
				info$SADR = ADR_Format(ADR, LEN, T);;
	}


	#If the NPDU packet has a Message Type, parse the data
	if (NPDU$Control & 0x80 == 0x80)
		info$Message_Type = MessageType(APDU);

	#If the NPDU packet has an APDU, parse the data
	if (NPDU$Control & 0x80 == 0x00)
		APDULogger(info, c, APDU);

	Log::write(bacnet::LOG, info);
	}

#Logs Forwarded NPDU packets
event bacnet_ethernet_NPDU_SD(c: connection, BVLC_Header : bacnet::BVLCHeaders, NPDU : bacnet::NPDUs, SNET : count, SLEN : count, DNET : count, DLEN : count, SADR : string, DADR : string, Hop_Count : count, APDU : string)  &priority=5
	{
	
	##print "Logging NPDU with source packet!!!";

	local info: Info;
	info$ts  	= network_time();
	info$uid 	= c$uid;
	info$id  	= c$id;
	info$Function 	= BVLC_function_codes[BVLC_Header$Function];
	info$Control 	= NPDU$Control;
	info$DNET	= DNET;
	info$Priority	= NPDU_prior_codes[(NPDU$Control & 0x03)];
	info$Expect_Reply = NPDU_reply[(NPDU$Control & 0x04)];


	if (NPDU$Control & 0x50 > 0)					#Bits 4 & 6 must = 0
	{
		local ctr = Weird::Info($ts=network_time(), $name="BACnet/IP invalid NPDU Control field value", $uid=c$uid, $id=c$id);
		Weird::weird(ctr);
	}

	#Forwarded NPDUs include a BIP; other NPDU types do not.
	if (BVLC_Header$Function == 0x04)
		info$BIP 	= fmt("%s",NPDU$IP) + ":" + fmt("%d",NPDU$Port);

	#Log whether the NPDU has a broadcast address or a destination address
	if ( DLEN == 0)
		info$DADR = "Broadcast";
	else
		info$DADR = ADR_Format(DADR, DLEN, F);

	#Log NPDU source netowrk
	info$SNET	= SNET;

	#Log NPDU souece address.  Per ASHRAE 135-2016, and SLEN =0 is invalid.  A lot of deivces donn't follow the standard and provide an SLEN = 0 :(
	if ( SLEN == 0)
		info$SADR = "Invalid";
	else
		info$SADR = ADR_Format(SADR, SLEN, T);;	


	#If the NPDU packet has a Message Type, parse the data
	if (NPDU$Control & 0x80 == 0x80)
		info$Message_Type = MessageType(APDU);

	#If the NPDU packet has an APDU, parse the data
	if (NPDU$Control & 0x80 == 0x00)
		APDULogger(info, c, APDU);

	Log::write(bacnet::LOG, info);
	}



# -----------------------------Helper Functions -------------------------------

#Returns the appropriate APDU Type and info as a string
function APDULogger(info : Info, c: connection, APDU: string)
	{
	#print "-In APDU Logger-";
		local APDU_first	: count = bytestring_to_count(APDU[0:1]);
		local APDU_Type		: count = ( APDU_first / 16 ); #APDU type is determined by the highest 4 bits of the first APDU byte
		local APDU_Data		: string = "";
		local start_byte	: count;
		local temp		: count;
		local wrd		: Weird::Info;
		info$APDU_Type = APDU_message_type[APDU_Type];

		switch APDU_Type
			{
				#BACnet-Confirmed-Request-PDU
				case 0x0:
					start_byte = 3; #If the APDU is not segmeneted, then the service choice starts at byte 3.  If segmeneted, then it will start at byte 5.
					if(APDU_first & 0x08 == 0x08)
						{
						APDU_Data += "Segmented |";
						info$APDU_Seq_Num = bytestring_to_count(APDU[3:4]);

						temp = bytestring_to_count(APDU[4:5]);
						info$APDU_Prop_Win_Size = temp;

						if ((temp) < 1 || (temp > 127))	
							{
							wrd = Weird::Info($ts=network_time(), $name="BACnet/IP invalid Proposed Window Size", $uid=c$uid, $id=c$id);
							Weird::weird(wrd);
							}

						start_byte = 5;
						}
					if(APDU_first & 0x04 == 0x04)
						APDU_Data += "No more segs follow |";
					if(APDU_first & 0x02 == 0x02)
						APDU_Data += "Segmeneted response accepted";

					if(|APDU_Data| > 0)
						info$APDU_Data = APDU_Data;

					temp = bytestring_to_count(APDU[1:2]);
					info$APDU_Max_Segs 	= APDU_Max_Segs[( (0x70 & temp) / 16 )]; 	#Max segments is bits 4, 5, & 6 of the second APDU byte
					info$APDU_Max_Resp 	= APDU_Max_Resp[( 0x0F & temp)]; 		#Max response size is bits 0-3 of the second APDU byte
					info$APDU_Invoke_ID 	= bytestring_to_count(APDU[2:3]);
					info$APDU_Srvc_Choice 	= APDU_C_Service[bytestring_to_count(APDU[start_byte:start_byte + 1])];
					break;

				case 0x1:
					info$APDU_Srvc_Choice 	= APDU_C_Service[bytestring_to_count(APDU[1:2])];					
					break;

				case 0x2:
					info$APDU_Invoke_ID 	= bytestring_to_count(APDU[1:2]);
					info$APDU_Srvc_Choice 	= APDU_C_Service[bytestring_to_count(APDU[2:3])];					
					break;

				case 0x3:
					start_byte = 2;
					if(APDU_first & 0x08 == 0x08)
						{
						APDU_Data += "Segmented |";
						info$APDU_Seq_Num = bytestring_to_count(APDU[2:3]);

						temp = bytestring_to_count(APDU[3:4]);
						info$APDU_Prop_Win_Size = temp;

						if ((temp) < 1 || (temp > 127))	
							{
							wrd = Weird::Info($ts=network_time(), $name="BACnet/IP invalid Proposed Window Size", $uid=c$uid, $id=c$id);
							Weird::weird(wrd);
							}

						start_byte = 4;
						}
					if(APDU_first & 0x04 == 0x04)
						APDU_Data += "No more segs follow";

					if(|APDU_Data| > 0)
						info$APDU_Data = APDU_Data;

					info$APDU_Srvc_Choice 	= APDU_C_Service[bytestring_to_count(APDU[start_byte:start_byte + 1])];
					break;

				case 0x4:
					if(APDU_first & 0x02 == 0x02)
						APDU_Data += "NAK - segment out of order |";

					if(APDU_first & 0x01 == 0x01)
						APDU_Data += "Sent by server";
					else
						APDU_Data += "Sent by client";

					if(|APDU_Data| > 0)
						info$APDU_Data = APDU_Data;

					info$APDU_Invoke_ID 	= bytestring_to_count(APDU[1:2]);
					info$APDU_Seq_Num = bytestring_to_count(APDU[2:3]);

					temp = bytestring_to_count(APDU[3:4]);
					info$APDU_Act_Win_Size = temp;
					if ((temp) < 1 || (temp > 127))	
						{
						wrd = Weird::Info($ts=network_time(), $name="BACnet/IP invalid Actual Window Size", $uid=c$uid, $id=c$id);
						Weird::weird(wrd);
						}
					break;

				case 0x5:
					info$APDU_Invoke_ID 	= bytestring_to_count(APDU[1:2]);
					info$APDU_Srvc_Choice 	= APDU_C_Service[bytestring_to_count(APDU[2:3])];					
					break;

				case 0x6:
					info$APDU_Invoke_ID 	= bytestring_to_count(APDU[1:2]);
					info$APDU_Data 		= "Rejected due to: " + APDU_Reject[bytestring_to_count(APDU[2:3])];					
					break;

				case 0x7:
					if(APDU_first & 0x01 == 0x01)
						APDU_Data += "Sent by server";
					else
						APDU_Data += "Sent by client";
					info$APDU_Invoke_ID 	= bytestring_to_count(APDU[1:2]);
					info$APDU_Data 		= " | Aborted due to: " + APDU_Abort[bytestring_to_count(APDU[2:3])];					
					break;

			}

	}

#Returns the appropriate NPDU Message Type and info as a string
function MessageType(APDU: string): string
	{
		local info: Info;
		local message_code 	: count;
		local message_string	: string;
		local p 		: count = 0;
		local num_ports		: count = 0;
		local port_lenA		: count = 0;
		local port_lenB		: count = 0;

		message_code = bytestring_to_count(APDU[0:1]);
		
		if (message_code <= 0x13)
			message_string = NPDU_message_type[message_code];
		else
			if ((message_code > 0x13) && (message_code <= 0x7F))
				message_string = "Code reserved by ASHRAE";
			else
				message_string = "Vendor proprietary code = " + fmt("%d", bytestring_to_count(APDU[1:3]));

		switch message_code
    		{
			case 0x00, 0x09:

				if (|APDU| > 2 )
					message_string += " DNET = " + fmt("%d", bytestring_to_count(APDU[1:3]));
				break;

			case 0x01, 0x04, 0x05:		
				if (|APDU| > 2)
				{
				message_string += " NET(s) = ";
	
	
				while(p < (|APDU[1:]|/2))
					{
					if (p > 0)
						message_string += " | ";
	
					message_string += fmt("%d",bytestring_to_count(APDU[1+(p*2):3+(p*2)]));
					p = p +1;
					}
					
				}
				break;

			case 0x02:
				message_string += " DNET = " + fmt("%d", bytestring_to_count(APDU[1:3])) + " | Perf Index = " + fmt("%d", bytestring_to_count(APDU[3:4]));
				break;

			case 0x03:

				message_string += " - " + Reject_Message[bytestring_to_count(APDU[1:2])] + " | DNET = " + fmt("%d", bytestring_to_count(APDU[2:4]));
				break;

			case 0x06, 0x07:
				num_ports = bytestring_to_count(APDU[1:2]);
				message_string += " - # Ports = " + fmt("%d", num_ports);

				if (num_ports == 0)
					message_string += " - Return complete routing table in an Initialize-Routing-Table-Ack";

				p = 0;	#Parse out routing table initialization: # of ports: 1 byte, Connected DNET: 2 bytes, Port ID: 1 byte, Port info length: 1 byte, Port Info: [Port info lenght] bytes | repeat DNET thru Port Info as needed 
				while(p < num_ports)
					{	
					if (p ==0)
						{
						port_lenA = bytestring_to_count(APDU[5:6]);
						message_string += " -" + "DNET = " + fmt("%d",bytestring_to_count(APDU[2:4]))
								+ " Port ID = " + fmt("%d",bytestring_to_count(APDU[4:5]))
								+ " Info = " + fmt("%s", APDU[6:6 + port_lenA]);
						}
					else
						{
						message_string += " | ";
						port_lenB = bytestring_to_count(APDU[port_lenA + (4*p) + 5 : port_lenA + (4*p) + 6]);
						message_string += " -" + "DNET = " + fmt("%d",bytestring_to_count(APDU[port_lenA+(4*p)+2 : port_lenA + (4*p)+4]))
								+ " Port ID = " + fmt("%d",bytestring_to_count(APDU[port_lenA + (4*p) + 4 : port_lenA + (4*p) + 5]))
								+ " Info = " + fmt("%s", APDU[port_lenA + (4*p) + 6 : port_lenB + (4*p) + 6]);

						port_lenA += port_lenB;
						}
					p = p +1;
					}

				break;
		
			case 0x08:
				message_string += "DNET = " + fmt("%d", bytestring_to_count(APDU[1:3])) + " | TTV = " + fmt("%d", bytestring_to_count(APDU[3:4]));
				break;

# Cases 0x00 - 0x08 tested SAT
#TODO TO DO - Need to test security messages

			case 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12:
				info$Sec_Control 	= bytestring_to_count(APDU[1:2]);
				info$Sec_Key_Rev 	= bytestring_to_count(APDU[2:3]);
				info$Sec_Key_ID  	= bytestring_to_count(APDU[3:5]);
				info$Sec_SDI     	= bytestring_to_count(APDU[5:8]);
				info$Sec_Message_ID 	= bytestring_to_count(APDU[8:12]);
				info$Sec_Time_Stamp	= bytestring_to_count(APDU[12:16]);
				break;

			case 0x13:
				message_string += "NET = " + fmt("%d", bytestring_to_count(APDU[1:3]));
				if (bytestring_to_count(APDU[3:4]) > 0)
					message_string += " - Network number was configured";
				else
					message_string += " - Network number was learned from other devices on the network";
				break;
		}

		return message_string;
	}


#Takes in the various NPDU address formats and returns an appropriate string
function ADR_Format(ADR: string, LEN: count, SD: bool): string
	{
		local ADDR : string;
		switch LEN
    		{
		    case 1:
		        ADDR = fmt("ARCNET or MS/TP: %d",bytestring_to_count(ADR));
			break;

		# ############# TODO: NEED TO TEST LONTALK CASES
		    case 2:
			# If Source Address SD == 1, else SD == 0 and it's a pain in the neck destination address
		        if (SD)
				ADDR = fmt("LonTalk: %d:%d",bytestring_to_count(ADR[0]), bytestring_to_count(ADR[1]));
			else
			{
				if(bytestring_to_count(ADR[0]) == 0x00)
					ADDR = fmt("LonTalk Dst Subnet: %d", bytestring_to_count(ADR[1]));
				else
					if(bytestring_to_count(ADR[0]) == 0x00)
						ADDR = fmt("LonTalk Dst Group: %d", bytestring_to_count(ADR[1]));
			}
			break;

		# ############# TODO: IPv6 not supported in this analyzer (yet?)
		    case 3:
		        ADDR = fmt("IPv6 not supported by this analyzer: %d", bytestring_to_count(ADR));
			break;

		    case 6:
			local BIPa 	: addr;
			local BIPp 	: count;

			BIPa  = raw_bytes_to_v4_addr(ADR);	
			BIPp  = bytestring_to_count(ADR[4:6]);
		
			ADDR = fmt("IPv4: %s",BIPa) + ":" + fmt("%d",BIPp);
		        break;

		# ############# TODO: NEED TO TEST LONTALK CASES
		    case 7:
		        ADDR = fmt("LonTalk Dst Subnet: %d Neuron ID: %d", bytestring_to_count(ADR[0]), bytestring_to_count(ADR[1:7]));
			break;

		    default:
		        ADDR = fmt("Unknown protocol src/dst addr: %d", bytestring_to_count(ADR));
			break;
    		}

		return ADDR;
	}
