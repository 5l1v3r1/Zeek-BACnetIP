%extern{
//	#include <cctype>
//	#include <unordered_set>
//	#include "consts.bif.h"
	#include "types.bif.h"
%}
#
%header{
	RecordVal* BVLCHeaderToZeek(BVLC_Header_Type *header);
	RecordVal* NPDUToZeek(NPDU_Header_Type *NPDUField);
	RecordVal* MiniNPDUToZeek(NPDU_Header_No_Type *MiniNPDUField);
	%}
#
%code{
	RecordVal* BVLCHeaderToZeek(BVLC_Header_Type *header)
		{
		RecordVal* BVLC_header = new RecordVal(BifType::Record::bacnet::BVLCHeaders);
		BVLC_header->Assign(0, new Val(header->Type(), TYPE_COUNT));
		BVLC_header->Assign(1, new Val(header->Function(), TYPE_COUNT));
		BVLC_header->Assign(2, new Val(header->Length(), TYPE_COUNT));
			return BVLC_header;
		}

	RecordVal* NPDUToZeek(NPDU_Header_Type *NPDUField)
		{

		RecordVal* NPDU = new RecordVal(BifType::Record::bacnet::NPDUs);
		NPDU->Assign(0, new AddrVal(htonl(${NPDUField.IP})));
		NPDU->Assign(1, new Val(${NPDUField.Port}, TYPE_COUNT));
		NPDU->Assign(2, new Val(${NPDUField.Version}, TYPE_COUNT));
		NPDU->Assign(3, new Val(${NPDUField.Control}, TYPE_COUNT));
			return NPDU;
		}

	RecordVal* MiniNPDUToZeek(NPDU_Header_No_Type *MiniNPDUField)
		{

		RecordVal* NPDU = new RecordVal(BifType::Record::bacnet::MiniNPDUs);
		NPDU->Assign(0, new Val(${MiniNPDUField.Version}, TYPE_COUNT));
		NPDU->Assign(1, new Val(${MiniNPDUField.Control}, TYPE_COUNT));
			return NPDU;
		}


     %}

# Generated by binpac_quickstart

refine flow bacnet_Flow += {

## Handles BVLC Results packets
	function deliver_BVLC_Result(BVLC_Header: BVLC_Header_Type, Payload: BVLC_Result_Type): bool
		%{

			//printf("BVLC-Result Packet\n");
			BifEvent::generate_bacnet_ethernet_BVLC_Result(connection()->bro_analyzer(),
			                                             connection()->bro_analyzer()->Conn(),
			                                             BVLCHeaderToZeek(BVLC_Header),
								     ${Payload.Result});

		return true;
		%}

## Handles BVLC Broadcast Distribution Table Read Ack and Write packets
	function deliver_BVLC_BDT(BVLC_Header : BVLC_Header_Type, BDT: BVLC_BDT_Type): bool
		%{

			//printf("BVLC-BDT Packet - ");
			BifEvent::generate_bacnet_ethernet_BVLC_Broadcast_Distribution_Table(connection()->bro_analyzer(),
			                                             connection()->bro_analyzer()->Conn(),
			                                             BVLCHeaderToZeek(BVLC_Header),
								     new StringVal(${BDT.Table}.length(), (const char*) ${BDT.Table}.begin()));

		return true;
		%}

## Handles BVLC Read Broadcast Distribution Table or Foreign Device Table packets
	function deliver_BVLC_BVLC_B_F(BVLC_Header : BVLC_Header_Type): bool
		%{

			//printf("BVLC-Read BDT or FDT");
			BifEvent::generate_bacnet_ethernet_BVLC_Read_B_F(connection()->bro_analyzer(),
			                                             connection()->bro_analyzer()->Conn(),
			                                             BVLCHeaderToZeek(BVLC_Header));
		return true;
		%}

## Handles BVLC Register Foreign Device packets
	function deliver_BVLC_RFD(BVLC_Header: BVLC_Header_Type, RFD: BVLC_RFD_Type): bool
		%{

			//printf("BVLC-Register-Foreign-Device Packet\n");
			BifEvent::generate_bacnet_ethernet_BVLC_RFD(connection()->bro_analyzer(),
			                                             connection()->bro_analyzer()->Conn(),
			                                             BVLCHeaderToZeek(BVLC_Header),
								     ${RFD.TTL});

		return true;
		%}


## Handles BVLC Read Foreign Device Table Ack packets
	function deliver_BVLC_Read_FDT_Ack(BVLC_Header : BVLC_Header_Type, FDT: BVLC_Read_FDT_Ack_Type): bool
		%{

			//printf("BVLC-BDT Packet - ");
			BifEvent::generate_bacnet_ethernet_BVLC_Read_Foreign_Device_Table_Ack(connection()->bro_analyzer(),
			                                             connection()->bro_analyzer()->Conn(),
			                                             BVLCHeaderToZeek(BVLC_Header),
								     new StringVal(${FDT.Table}.length(), (const char*) ${FDT.Table}.begin()));

		return true;
		%}


## Handles BVLC Read Foreign Device Table Ack packets
	function deliver_BVLC_Del_FD(BVLC_Header : BVLC_Header_Type, FDE: BVLC_Del_FD_Type): bool
		%{

			//printf("BVLC-Del Foreign Device Entry - ");
			BifEvent::generate_bacnet_ethernet_BVLC_Del_FD(connection()->bro_analyzer(),
			                                             connection()->bro_analyzer()->Conn(),
			                                             BVLCHeaderToZeek(BVLC_Header),
								     new StringVal(${FDE.Entry}.length(), (const char*) ${FDE.Entry}.begin()));

		return true;
		%}

# Handles BVLC secure packets  TO DO: Could not test this
	function deliver_BVLC_Secure(BVLC_Header : BVLC_Header_Type): bool
		%{

			BifEvent::generate_bacnet_ethernet_BVLC_Secure(connection()->bro_analyzer(),
			                                             connection()->bro_analyzer()->Conn(),
			                                             BVLCHeaderToZeek(BVLC_Header));

		return true;
		%}


# -------------------------------------------------NPDU

# Handles BACnet packets with an NPDU with destination only fields and an APDU
	function deliver_APDU_Dst(BVLC_Header : BVLC_Header_Type, NPDU_Header : NPDU_Header_Type, NPDU_APDU : APDU_Dst_Type): bool
		%{
			//printf("NPDU Dst in C code!!!\n");
			BifEvent::generate_bacnet_ethernet_NPDU(connection()->bro_analyzer(),
			                                             connection()->bro_analyzer()->Conn(),
			                                             BVLCHeaderToZeek(BVLC_Header),
									NPDUToZeek(NPDU_Header),
									${NPDU_APDU.DNET},
									${NPDU_APDU.DLEN},
									(${NPDU_APDU.DLEN} > 0) ? new StringVal(${NPDU_APDU.DADR}.length(), (const char*) ${NPDU_APDU.DADR}.begin()) : new StringVal(1,"-"),
									${NPDU_APDU.Hop_Count},
									new StringVal(${NPDU_APDU.APDU}.length(), (const char*) ${NPDU_APDU.APDU}.begin()));
			return true;
		%}


# Handles BACnet packets with an NPDU with source only fields and an APDU
	function deliver_APDU_Src(BVLC_Header : BVLC_Header_Type, NPDU_Header : NPDU_Header_Type, NPDU_APDU : APDU_Src_Type): bool
		%{
			//printf("NPDU Src in C code!!!\n");
			BifEvent::generate_bacnet_ethernet_NPDU(connection()->bro_analyzer(),
			                                             connection()->bro_analyzer()->Conn(),
			                                             BVLCHeaderToZeek(BVLC_Header),
									NPDUToZeek(NPDU_Header),
									${NPDU_APDU.SNET},
									${NPDU_APDU.SLEN},
									new StringVal(${NPDU_APDU.SADR}.length(), (const char*) ${NPDU_APDU.SADR}.begin()),
									0,
									new StringVal(${NPDU_APDU.APDU}.length(), (const char*) ${NPDU_APDU.APDU}.begin()));
			return true;
		%}

# Handles BACnet packets with an NPDU source and destination fields and an APDU
	function deliver_APDU_Src_Dst(BVLC_Header : BVLC_Header_Type, NPDU_Header : NPDU_Header_Type, NPDU_APDU : APDU_Src_Dst_Type): bool
		%{
			//printf("NPDU Src/Dst in C code!!!\n");
			BifEvent::generate_bacnet_ethernet_NPDU_SD(connection()->bro_analyzer(),
			                                             connection()->bro_analyzer()->Conn(),
			                                             BVLCHeaderToZeek(BVLC_Header),
									NPDUToZeek(NPDU_Header),
									${NPDU_APDU.SNET},
									${NPDU_APDU.SLEN},
									${NPDU_APDU.DNET},
									${NPDU_APDU.DLEN},
									new StringVal(${NPDU_APDU.SADR}.length(), (const char*) ${NPDU_APDU.SADR}.begin()),
									new StringVal(${NPDU_APDU.DADR}.length(), (const char*) ${NPDU_APDU.DADR}.begin()),
									${NPDU_APDU.Hop_Count},
									new StringVal(${NPDU_APDU.APDU}.length(), (const char*) ${NPDU_APDU.APDU}.begin()));
			return true;
		%}


# Handles BACnet packets with an NPDU that transmits an APDU with no other info
	function deliver_APDU(BVLC_Header : BVLC_Header_Type, NPDU_Header : NPDU_Header_Type, APDU_T : APDU_Type): bool
		%{
			//printf("APDU only packet in C code!!!\n");
			BifEvent::generate_bacnet_ethernet_NPDU(connection()->bro_analyzer(),
			                                             connection()->bro_analyzer()->Conn(),
			                                             BVLCHeaderToZeek(BVLC_Header),
									NPDUToZeek(NPDU_Header),
									0,
									0,
									new StringVal(1,"-"),
									0,
									new StringVal(${APDU_T.APDU}.length(), (const char*) ${APDU_T.APDU}.begin()));
			return true;
		%}

# -----------------------------APDU No's

# Handles BACnet packets with an NPDU with destination only fields and an APDU
	function deliver_APDU_Dst_No(BVLC_Header : BVLC_Header_Type, NPDU_Header : NPDU_Header_No_Type, NPDU_APDU : APDU_Dst_No_Type): bool
		%{
			//printf("APDU_Dst_No!!!  BVLC Type: %d\n", ${BVLC_Header.Function});
			BifEvent::generate_bacnet_ethernet_NPDU_No(connection()->bro_analyzer(),
			                                             connection()->bro_analyzer()->Conn(),
			                                             BVLCHeaderToZeek(BVLC_Header),
									MiniNPDUToZeek(NPDU_Header),
									${NPDU_APDU.DNET},
									${NPDU_APDU.DLEN},
									(${NPDU_APDU.DLEN} > 0) ? new StringVal(${NPDU_APDU.DADR}.length(), (const char*) ${NPDU_APDU.DADR}.begin()) : new StringVal(1,"-"),
									${NPDU_APDU.Hop_Count},
									new StringVal(${NPDU_APDU.APDU}.length(), (const char*) ${NPDU_APDU.APDU}.begin()));
			return true;
		%}


# Handles BACnet packets with an NPDU with source only fields and an APDU
	function deliver_APDU_Src_No(BVLC_Header : BVLC_Header_Type, NPDU_Header : NPDU_Header_No_Type, NPDU_APDU : APDU_Src_No_Type): bool
		%{
			//printf("APDU_Src_No!!!  BVLC Type: %d\n", ${BVLC_Header.Function});
			BifEvent::generate_bacnet_ethernet_NPDU_No(connection()->bro_analyzer(),
			                                             connection()->bro_analyzer()->Conn(),
			                                             BVLCHeaderToZeek(BVLC_Header),
									MiniNPDUToZeek(NPDU_Header),
									${NPDU_APDU.SNET},
									${NPDU_APDU.SLEN},
									new StringVal(${NPDU_APDU.SADR}.length(), (const char*) ${NPDU_APDU.SADR}.begin()),
									0,
									new StringVal(${NPDU_APDU.APDU}.length(), (const char*) ${NPDU_APDU.APDU}.begin()));
			return true;
		%}

# Handles BACnet packets with an NPDU source and destination fields and an APDU
	function deliver_APDU_Src_Dst_No(BVLC_Header : BVLC_Header_Type, NPDU_Header : NPDU_Header_No_Type, NPDU_APDU : APDU_Src_Dst_No_Type): bool
		%{
			//printf("APDU_Src_Dst_No!!!  BVLC Type: %d\n", ${BVLC_Header.Function});
			BifEvent::generate_bacnet_ethernet_NPDU_SD_No(connection()->bro_analyzer(),
			                                             connection()->bro_analyzer()->Conn(),
			                                             BVLCHeaderToZeek(BVLC_Header),
									MiniNPDUToZeek(NPDU_Header),
									${NPDU_APDU.SNET},
									${NPDU_APDU.SLEN},
									${NPDU_APDU.DNET},
									${NPDU_APDU.DLEN},
									new StringVal(${NPDU_APDU.SADR}.length(), (const char*) ${NPDU_APDU.SADR}.begin()),
									new StringVal(${NPDU_APDU.DADR}.length(), (const char*) ${NPDU_APDU.DADR}.begin()),
									${NPDU_APDU.Hop_Count},
									new StringVal(${NPDU_APDU.APDU}.length(), (const char*) ${NPDU_APDU.APDU}.begin()));
			return true;
		%}


# Handles BACnet packets with an NPDU that transmits an APDU with no other info
	function deliver_APDU_No(BVLC_Header : BVLC_Header_Type, NPDU_Header : NPDU_Header_No_Type, APDU_T : APDU_No_Type): bool
		%{
			//printf("APDU_No!!!  BVLC Type: %d\n", ${BVLC_Header.Function});
			BifEvent::generate_bacnet_ethernet_NPDU_No(connection()->bro_analyzer(),
			                                             connection()->bro_analyzer()->Conn(),
			                                             BVLCHeaderToZeek(BVLC_Header),
									MiniNPDUToZeek(NPDU_Header),
									0,
									0,
									new StringVal(1,"-"),
									0,
									new StringVal(${APDU_T.APDU}.length(), (const char*) ${APDU_T.APDU}.begin()));
			return true;
		%}

# Handles BACnet packets with BVLC functions that are not defined by ASHRAE 135-2016
	function deliver_Unknown_BVLC(BVLC_Header : BVLC_Header_Type): bool
		%{
			BifEvent::generate_bacnet_ethernet_BVLC_Unknown_Type(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(),
				${BVLC_Header.Type},
				${BVLC_Header.Function});
			return true;
		%}

	function proc_bacnet_message(msg: BACNET_PDU): bool
		%{
		
				return true;

		%}
};

refine typeattr BACNET_PDU += &let {
	proc: bool = $context.flow.proc_bacnet_message(this);
};


#refine typeattr bacnet_Packet += &let {
#	proc = $context.connection.process_packet(this, is_orig);
#};
